前面介绍过，数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。考虑下面的数组声明：
/* 一些数组声明*/
`int　main(void)
``{
`float candy[365];　　　 /* 内含365个float类型元素的数组 */
`char code[12];　　　　　/*内含12个char类型元素的数组*/
`int states[50];　　　　 /*内含50个int类型元素的数组 */
``...
``}

初始化数组：
`int powers[8] = {1,2,4,6,8,16,32,64};
如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小

而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：
`int arr[6] = {[5] = 212};` // 把arr\[5]初始化为212
第一，如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：\[4] = 31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。
第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如，程序清单10.5中，初始化列表开始时把days\[1]初始化为28，但是days\[1]又被后面的指定初始化\[1] = 29初始化为29。

## 多维数组

float rain\[5]\[12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素


## 数组和指针
数组名是数组首元素的地址。也就是说，如果flizny是一个数组，下面的语句成立：
flizny == &flizny\[0]; // 数组名是该数组首元素的地址

## 多维数组的指针
i`nt zippo[4][2]; /* 内含int数组的数组 */

`因为zippo是数组首元素的地址，所以zippo的值和&zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素（一个整数）的地址（即&zippo[0][0]的值）相同。

`给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的对象只占用一个int大小。因此， zippo + 1和zippo[0] + 1的值不同。

`解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的[]运算符，得到引用对象代表的值。因为zippo[0]是该数组首元素（zippo[0][0]）的地址，所以*(zippo[0])表示储存在zippo[0][0]上的值（即一个int类型的值）。与此类似，*zippo代表该数组首元素（zippo[0]）的值，但是zippo[0]本身是一个int类型值的地址。该值的地址是&zippo[0][0]，所以*zippo就是&zippo[0][0]。