
使用bfs和dfs区别:bfs是不保存上一步的信息的,而dfs会保存路径的信息;因此大部分选择方案的题目都是用dfs,像排列和组合的题目大多用dfs;而大部分找有几条路,或者最短路径则是使用bfs;
bfs和dfs实际上是互通的,复杂的bfs结构也可以保存路径信息,在遍历所有可能的情况下bfs和dfs的计算量是一样的.

# 讲dfs分为两个类别:排列和组合;

## 组合
```cpp
dfs(int flag, int over){
	if(停止条件){
		计算（非必须）；
		给ans赋值；
		return;
	}
	for (int now = flag; now < N; now++) {
		选方案；
		dfs(flag+1，0);
		去除选择的方案；
	}
	dfs(flag,1);
}

```
### dfs参数：
1.flag:标记可选的位置；
2.over:标记选择结束；
### 终止条件有两种：
1.选择over，开始计算和赋值；
2.已经超出最大或最小值，直接return；
这两种基本分开写，所以有的题会有两个if；
计算会单独写一个函数，如果在dfs步骤中顺便计算过了的话，那就不用单独写；
### 循环：
循环是从flag到N在每一次选择中选用方案；
这里的选择和去选择根据每一个题目不同而变化，对应不同操作；
最后会加一个dfs（flag，1）表示选择完毕，对应不全选的一些方案；


## 排列
```cpp
dfs(int over){
	if(停止条件){
		计算（非必须）；
		给ans赋值；
		return;
	}
	for (int now = 0; now < N; now++) {
		if(visited[now]==0){
			选方案；
			visited[i]=1;
			dfs(flag+1，0);
			去除选择的方案；
			visited[i]=0;
		}
	}
	dfs(flag,1);
}
```
排列就不需要flag进行定位了；

# 变体：
如果一个方案有多种可能：如虫洞的正反和矩阵的反转，则要在f循环中增加多个dfs；
